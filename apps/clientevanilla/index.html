<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="utf-8">
    <title>Ejemplo VR Paisaje - Rulocode</title>
    <meta name="description" content="Ejemplo simple de VR con paisaje usando A-Frame y assets locales">
    <script src="aframe-v1.3.0.min.js"></script>
    <script src="scenes-config.js"></script>
    <script src="websocket-client.js"></script>
    <style>
      body { margin: 0; }
      .a-loader-title { font-family: sans-serif; }
    </style>
  </head>
  <body>
    <a-scene background="color: #88c">
      <!-- Audio y assets - Dynamic loading -->
      <a-assets>
        <audio id="current-audio" src="audio/ambient-wind.mp3"></audio>
        <img id="current-skybox" src="images/escena_1.png">
      </a-assets>

      <!-- Scene loading overlay -->
      <a-entity id="scene-overlay"
                geometry="primitive: plane; width: 10; height: 6"
                material="color: black; opacity: 0"
                position="0 0 -2"
                visible="false">
        <a-text value="Loading Scene..."
                position="0 0 0.01"
                align="center"
                color="white"
                scale="2 2 2"></a-text>
      </a-entity>

      <!-- Audio component -->
      <a-sound id="scene-sound"
               src="#current-audio"
               autoplay="true"
               loop="true"
               volume="0.5"></a-sound>

      <!-- Skybox esfÃ©rico -->
      <a-sky id="scene-skybox"
             src="#current-skybox"
             rotation="0 -90 0"></a-sky>

      <!-- Lighting system -->
      <a-entity id="ambient-light"
                light="type: ambient; color: #ffffff; intensity: 0.7"></a-entity>

      <a-entity id="directional-light"
                light="type: directional; color: #ffeeaa; intensity: 0.8"
                position="0 1 1"></a-entity>

      <!-- 3D Models container (empty for clean 360Â° view) -->
      <a-entity id="scene-models">
        <!-- Models will be loaded dynamically from scene config -->
      </a-entity>

      <!-- CÃ¡mara y controles VR -->
      <a-entity camera look-controls wasd-controls position="0 1.6 5"></a-entity>

      <script>
        // VR Scene Management System
        let vrClient = null;
        let currentSceneId = 'escena-1'; // Default scene
        let sceneManager = null;

        // Scene Manager Class
        class VRSceneManager {
          constructor() {
            this.currentScene = null;
            this.isLoading = false;
            this.elements = {};
            this.initializeElements();
          }

          initializeElements() {
            this.elements = {
              skybox: document.querySelector('#scene-skybox'),
              sound: document.querySelector('#scene-sound'),
              ambientLight: document.querySelector('#ambient-light'),
              directionalLight: document.querySelector('#directional-light'),
              models: document.querySelector('#scene-models'),
              overlay: document.querySelector('#scene-overlay'),
              assets: {
                audio: document.querySelector('#current-audio'),
                skybox: document.querySelector('#current-skybox')
              }
            };
          }

          async loadScene(sceneId) {
            console.log('ðŸ” loadScene called with:', sceneId);
            console.log('ðŸ” Available scenes:', Object.keys(SCENES_CONFIG));
            console.log('ðŸ” Scene exists?', !!SCENES_CONFIG[sceneId]);
            console.log('ðŸ” Full SCENES_CONFIG:', SCENES_CONFIG);

            if (this.isLoading) {
              console.warn('âš ï¸ Scene loading already in progress');
              return false;
            }

            if (!SCENES_CONFIG[sceneId]) {
              console.error('âŒ Scene not found:', sceneId);
              console.log('Available scenes:', Object.keys(SCENES_CONFIG));
              console.log('âŒ Attempted scene ID:', sceneId);
              console.log('âŒ Scene ID type:', typeof sceneId);
              console.log('âŒ Scene ID length:', sceneId.length);
              return false;
            }

            console.log('ðŸŽ¬ Loading scene:', sceneId);
            this.isLoading = true;
            this.showLoadingOverlay();

            const sceneConfig = SCENES_CONFIG[sceneId];

            try {
              // Update assets
              await this.updateAssets(sceneConfig);

              // Update scene elements
              this.updateSkybox(sceneConfig);
              this.updateLighting(sceneConfig);
              this.updateModels(sceneConfig);
              this.updateAudio(sceneConfig);

              this.currentScene = sceneConfig;
              currentSceneId = sceneId;

              console.log('âœ… Scene loaded successfully:', sceneId);

              // Notify server we're ready
              if (vrClient && vrClient.isConnected) {
                vrClient.sendReady(sceneId);
              }

              return true;
            } catch (error) {
              console.error('âŒ Error loading scene:', error);
              return false;
            } finally {
              this.isLoading = false;
              this.hideLoadingOverlay();
            }
          }

          async updateAssets(sceneConfig) {
            console.log('ðŸŽ¯ Updating assets for scene:', sceneConfig.id);
            console.log('ðŸžï¸ New skybox path:', sceneConfig.assets.skybox);
            console.log('ðŸ”Š New audio path:', sceneConfig.assets.audio);

            // Update audio asset
            this.elements.assets.audio.setAttribute('src', sceneConfig.assets.audio);

            // Update skybox asset
            this.elements.assets.skybox.setAttribute('src', sceneConfig.assets.skybox);

            console.log('âœ… Assets updated, waiting for load...');

            // Wait for assets to load
            return new Promise(resolve => setTimeout(resolve, 500));
          }

          updateSkybox(sceneConfig) {
            console.log('ðŸžï¸ Updating skybox to:', sceneConfig.assets.skybox);

            // Force A-Frame to reload the texture by temporarily removing and re-adding the src
            this.elements.skybox.removeAttribute('src');

            // Use a small delay to ensure the removal is processed
            setTimeout(() => {
              this.elements.skybox.setAttribute('src', '#current-skybox');
              console.log('âœ… Skybox updated successfully');
            }, 100);
          }

          updateLighting(sceneConfig) {
            const { ambient, directional } = sceneConfig.lighting;

            this.elements.ambientLight.setAttribute('light', {
              type: 'ambient',
              color: ambient.color,
              intensity: ambient.intensity
            });

            this.elements.directionalLight.setAttribute('light', {
              type: 'directional',
              color: directional.color,
              intensity: directional.intensity
            });
          }

          updateModels(sceneConfig) {
            // Clear existing models
            this.elements.models.innerHTML = '';

            // Add models from config if any
            if (sceneConfig.assets.models && sceneConfig.assets.models.length > 0) {
              sceneConfig.assets.models.forEach(model => {
                const modelEntity = document.createElement('a-entity');
                modelEntity.setAttribute('id', model.id);
                if (model.gltfModel) {
                  modelEntity.setAttribute('gltf-model', model.gltfModel);
                }
                modelEntity.setAttribute('position', model.position || '0 0 0');
                modelEntity.setAttribute('scale', model.scale || '1 1 1');
                this.elements.models.appendChild(modelEntity);
              });
            }
          }

          updateAudio(sceneConfig) {
            this.elements.sound.setAttribute('src', '#current-audio');
          }

          showLoadingOverlay() {
            this.elements.overlay.setAttribute('visible', 'true');
            this.elements.overlay.setAttribute('material', 'opacity', 0.8);
          }

          hideLoadingOverlay() {
            this.elements.overlay.setAttribute('visible', 'false');
            this.elements.overlay.setAttribute('material', 'opacity', 0);
          }
        }

        // Initialize WebSocket client after DOM loads
        document.addEventListener('DOMContentLoaded', function() {

          // Initialize Scene Manager
          sceneManager = new VRSceneManager();

          // Determine server URL based on current host
          const currentHost = window.location.hostname;
          const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
          const serverPort = window.location.protocol === 'https:' ? '8081' : '8081';
          const serverUrl = `${protocol}//${currentHost}:${serverPort}/ws`;

          console.log('ðŸ”— Connecting to WebSocket server:', serverUrl);

          // Initialize WebSocket client
          vrClient = new VRWebSocketClient({
            serverUrl: serverUrl,
            deviceId: `clientevanilla-${Date.now()}`,
            onConnect: () => {
              console.log('ðŸŽ® VR Client connected to server');
              console.log('ðŸ” Current scene ID on connect:', currentSceneId);
              // Send ready signal for current scene
              setTimeout(() => {
                console.log('ðŸ“¤ Sending READY signal for scene:', currentSceneId);
                vrClient.sendReady(currentSceneId);
              }, 1000);
            },
            onDisconnect: () => {
              console.log('ðŸ”Œ VR Client disconnected from server');
            },
            onCommand: (command) => {
              console.log('ðŸ“¨ Received command from server:', command);
              handleServerCommand(command);
            },
            onError: (error) => {
              console.error('ðŸš¨ VR Client error:', error);
            }
          });

          // Connect to server
          vrClient.connect();


          function sendStateUpdate() {
            // Send state update to server
            if (vrClient && vrClient.isConnected) {
              vrClient.sendState(currentSceneId, 0, true, 100);
            }
          }


          function handleServerCommand(command) {
            console.log('ðŸ“¢ Processing server command:', command);
            console.log('ðŸ“¢ Command type:', command.commandType);
            console.log('ðŸ“¢ Full command object:', JSON.stringify(command, null, 2));

            switch(command.commandType) {
              case 'LOAD':
                const newSceneId = command.sceneId;
                console.log('ðŸŽ¬ Loading scene from server:', newSceneId);
                console.log('ðŸ” Scene manager exists?', !!sceneManager);
                console.log('ðŸ” Available scenes:', Object.keys(SCENES_CONFIG || {}));
                console.log('ðŸ” Current scene ID before load:', currentSceneId);

                // Load the scene using scene manager
                if (sceneManager) {
                  console.log('ðŸš€ Calling sceneManager.loadScene with:', newSceneId);
                  sceneManager.loadScene(newSceneId).then(success => {
                    if (success) {
                      console.log('âœ… Scene loaded successfully from dashboard');
                      console.log('âœ… Current scene ID after load:', currentSceneId);
                    } else {
                      console.error('âŒ Failed to load scene from dashboard');
                      console.error('âŒ Scene config for', newSceneId, ':', SCENES_CONFIG[newSceneId]);
                    }
                  }).catch(error => {
                    console.error('ðŸ’¥ Error in loadScene promise:', error);
                  });
                } else {
                  console.error('âŒ Scene manager not initialized');
                }
                break;

              case 'START_AT':
                console.log('â–¶ï¸ Starting experience');
                // Start the experience
                break;

              case 'PAUSE':
                console.log('â¸ï¸ Pausing experience');
                // Pause audio and timeline
                const audioEl = document.querySelector('#scene-sound');
                if (audioEl) {
                  audioEl.components.sound.pauseSound();
                }
                break;

              case 'RESUME':
                console.log('â–¶ï¸ Resuming experience');
                // Resume audio and timeline
                const resumeAudioEl = document.querySelector('#scene-sound');
                if (resumeAudioEl) {
                  resumeAudioEl.components.sound.playSound();
                }
                break;

              case 'SEEK':
                console.log('â­ï¸ Seeking command received');
                // No timeline to seek anymore
                break;

              default:
                console.log('ðŸ¤· Unknown command:', command.commandType);
            }
          }


          // Expose to global scope for debugging
          window.vrClient = vrClient;
          window.sceneManager = sceneManager;
          window.handleServerCommand = handleServerCommand;
          window.SCENES_CONFIG = SCENES_CONFIG;

          // Test scene loading functions for development
          window.loadScene = (sceneId) => {
            if (sceneManager) {
              return sceneManager.loadScene(sceneId);
            } else {
              console.error('Scene manager not initialized');
              return false;
            }
          };


          console.log('ðŸŽ® VR Scene Controls Available:');
          console.log('  loadScene("escena-1") - Load EnergÃ­as Renovables scene');
          console.log('  loadScene("escena-2") - Load Operaciones Petroleras scene');
          console.log('  toggleScene() - Toggle between scenes manually');

          // Add a simple scene toggle function
          window.toggleScene = () => {
            if (sceneManager) {
              const newScene = currentSceneId === 'escena-1' ? 'escena-2' : 'escena-1';
              console.log(`ðŸ”€ Toggling to ${newScene}`);
              sceneManager.loadScene(newScene);
            }
          };
        });
      </script>
    </a-scene>
  </body>
</html>